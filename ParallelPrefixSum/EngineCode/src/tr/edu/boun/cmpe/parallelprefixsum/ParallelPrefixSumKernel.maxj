package tr.edu.boun.cmpe.parallelprefixsum;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

public class ParallelPrefixSumKernel extends Kernel {
	final static int SIZE_VECTOR = 1024;

	final DFEType TYPE_ELEMENT = dfeUInt(32);
	final DFEVectorType<DFEVar> TYPE_VECTOR = new DFEVectorType<DFEVar>(TYPE_ELEMENT, SIZE_VECTOR);

	protected ParallelPrefixSumKernel(KernelParameters parameters) {
		super(parameters);

		DFEVector<DFEVar> x = io.input("x", TYPE_VECTOR);
		DFEVector<DFEVar> y = TYPE_VECTOR.newInstance(this);

		DFEVar carriedSum = TYPE_ELEMENT.newInstance(this);
		DFEVar counter = control.count.simpleCounter(32);

		// calculate cumulative sums
		DFEVector<DFEVar> cumulativeSums = TYPE_VECTOR.newInstance(this);
		DFEVar previous = x.getElement(0);
		cumulativeSums.connect(0, previous);
		for(int i = 1; i < SIZE_VECTOR; i++) {
			DFEVar sum = previous + x.getElement(i);
			cumulativeSums.connect(i, sum);
			previous = sum;
		}

		optimization.pushPipeliningFactor(0.0);
		OffsetExpr loopLength = stream.makeOffsetAutoLoop("loopLength");
		DFEVar carry = counter.eq(0) ? 0 : carriedSum;
		for(int i = 0; i < SIZE_VECTOR - 1; i++) {
			DFEVar result = cumulativeSums.getElement(i) + carry;
			y.connect(i, result);
		}
		optimization.popPipeliningFactor();

		DFEVar newCarry = cumulativeSums.getElement(SIZE_VECTOR - 1) + carry;
		y.connect(SIZE_VECTOR - 1, newCarry);

		carriedSum <== stream.offset(newCarry, -loopLength);
		io.output("y", y, TYPE_VECTOR);
	}
}
